#+TITLE: .emacs --- Emacs init file
#+AUTHOR: Juri Linkov
#+EMAIL: juri@linkov.net
#+DATE: 2020-03-24
#+VERSION: GNU Emacs 28.0.50 (x86_64-pc-linux-gnu)
#+KEYWORDS: dotemacs, init
#+HTML_LINK_HOME: http://www.linkov.net/emacs
#+HTML_HEAD: <script type="text/javascript" src="load.js"></script>
#+ATTR_HTML: :target _blank
#+INFOJS_OPT: view:info toc:t
#+OPTIONS: broken-links:mark author:t creator:t timestamp:t email:t toc:t
#+PROPERTY: header-args:emacs-lisp :lexical yes
#+LINK: bug https://debbugs.gnu.org/%s

#+begin_quote
"/Show me your init file and I'll tell you who you are./" -- [[http://www.google.com/search?q=%22tell+you+who+you+are%22+intitle%3Aproverbs+site%3Awikiquote.org][old proverb]] slightly modified
#+end_quote

/Copyright (C) 1989-2020  Juri Linkov <juri@linkov.net>/

* Table of Content                                                      :TOC:

* Literate programming

First of all, as you may already noticed, this file follows the paradigm
called [[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]].  It is a text document that has both of these features:

1. Weaving: it is rendered to HTML while displayed either on GitLab/GitHub
   or when exported to HTML;
2. Tangling: the same document is executed during Emacs loading.

One line of code that initiates loading is in the separate file [[file:init.el][init.el]].
This makes it the smallest ~init.el~ file possible, having metric of just 1 [[https://en.wikipedia.org/wiki/Source_lines_of_code][SLOC]].
The single line in ~init.el~ is the following:

#+begin_src emacs-lisp :tangle no
(org-babel-load-file (locate-file "README.org" load-path))
#+end_src

It exports source code from this file to the file ~README.el~.
To support lexical binding, the output file should have the
~lexical-binding~ cookie in its header:

#+begin_src emacs-lisp
;;; .emacs --- Emacs init file  -*- lexical-binding: t; -*-
#+end_src

You can read more about details of weaving and tangling in [[info:org#Extracting Source Code][the Org manual]].

Using the same file ~README.org~ as an self-executable document
fits nicely into the definition of Emacs where Emacs is the
self-documenting editor, and this file is a self-documenting init file.

* Construction Kit

There are many different definitions what Emacs really is - some call it
Integrated Development Environment (IDE), some call it a Lisp machine, etc.
and all of them are right.  What definition would be more relevant in the
context of this configuration file is that Emacs not just an editor, but
the *Editor Construction Kit* - that means an editor creation system whose
blocks could be combined in infinitely many ways to build a completely new editor -
and not just an editor but anything possible: web browser, mail client, [[https://xkcd.com/378/][butterfly]]...
So Emacs is more like a UI framework.

And indeed, looking at different customizations, it's easy to notice that
none of them are like other editors based on the same Emacs core.
Their differences are so significant that it is hard to believe that they
come from the same source.

* Space-time optimization

While constructing an own editor, one of the most important goals is to
optimize it in both dimensions: in space and time.

Optimization of space means to make usage of screen space more optimal, and
optimization of time means to reduce time required to perform different tasks.

* Space optimization

By default, Emacs looks like a typical GUI application with the menu bar,
tool bar, scroll bars, etc.  The problem is that these nice-looking UI
elements occupy precious screen real estate.  Some parts of this configuration
deal with this problem by reclaiming unused space to maximize information
density on the screen.

** Remove unused display elements

Get rid of all space-wasting garbage and minimize clutter.

#+begin_src emacs-lisp
(and (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(and (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(and (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
(and (fboundp 'tooltip-mode) (fboundp 'x-show-tip) (tooltip-mode -1))
#+end_src

** Full-screen Emacs desktop

To use maximum screen space, my Emacs frame covers the entire screen
and has no menus, no toolbars, no scrollbars, no title and no borders.
Such customization on 1024x768 display mode and 6x10 font produces
Emacs text screen resolution 168 columns x 75 lines.
~split-window-horizontally~ gives two windows with 83 columns x 75 lines.
And ~follow-mode~ displays one buffer with 83 columns x 150 lines.
On 1366x768 this gives 225 columns x 75 lines, this means either
2 horizontally split windows each 112 columns wide, or
3 horizontally split windows each 75 columns wide.

#+begin_src emacs-lisp
(cond
 ((eq window-system 'x)
  ;;(create-fontset-from-ascii-font "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-koi8-*")
  (create-fontset-from-ascii-font "-misc-fixed-medium-r-*--10-*-*-*-*-*-*-*")
  (setq default-frame-alist
        (append
         '(
           ;; A lot of different fonts were tried to pick the best one:
           ;;(font . "-*-*-medium-r-normal--10-*-*-*-c-60-fontset-koi8_r_10")
           ;;? (font . "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-koi8-*")
           ;;? (font . "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-*-*")
           ;; (font . "-misc-fixed-medium-r-normal--10-100-75-75-c-60-iso10646-1")
           ;; (font . "-*-*-medium-r-*--10-*-*-*-*-*-fontset-iso8859_1_10")
           ;; (font . "-misc-fixed-medium-r-normal--10-*-*-*-c-60-iso8859-1")
           ;; Unlike iso8859-1, iso10646-* correctly combines accented chars:
           (font . "-misc-fixed-medium-r-normal--10-*-*-*-c-60-iso10646-*")
           (cursor-type . bar)
           ;; To win a lot of screen pixels:
           (vertical-scroll-bars . nil)
           (horizontal-scroll-bars . nil)
           (scroll-bar-width . 0)
           (internal-border-width . 0)
           (menu-bar-lines . 0)
           (tool-bar-lines . 0)
           (line-spacing . 0))
         default-frame-alist))))
#+end_src

To make the Emacs frame truly maximized, we need additionally make it ~undecorated~
that removes any remaining window decorations including the title bar:

#+begin_src emacs-lisp
(add-hook 'after-make-frame-functions 'toggle-frame-maximized)
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (set-frame-parameter frame 'undecorated t)
            ;; Some OS resources change background to grey, revert it back to white:
            (modify-frame-parameters frame (list (cons 'background-color "white")))
            ;; For some OS window managers that don't put focus to new frames:
            (select-frame-set-input-focus frame)))

;; Apply `undecorated' to new frames created by these commands:
(advice-add 'make-frame-on-monitor :around
            (lambda (orig-fun monitor &optional display parameters)
              (funcall orig-fun monitor display
                       (append '((undecorated . t)) parameters)))
            '((name . make-frame-on-monitor-undecorated)))

(advice-add 'make-frame-on-current-monitor :around
            (lambda (orig-fun &optional parameters)
              (funcall orig-fun (append '((undecorated . t)) parameters)))
            '((name . make-frame-on-current-monitor-undecorated)))

;; qv https://debbugs.gnu.org/31968 "Allow to hide title bar on maximize"
(set-frame-parameter nil 'undecorated t)
#+end_src

In earlier versions there was no way to unframe and maximize Emacs window from Emacs,
so it was necessary to use such code in =~/.sawfish/rc=:

#+begin_src lisp
(require 'sawfish.wm.state.maximize)
(define (my-customize-emacs-window w)
  (when (string-match "emacs" (nth 2 (get-x-property w 'WM_CLASS)))
    (window-put w 'type 'unframed)
    (maximize-window w)))
(add-hook 'before-add-window-hook my-customize-emacs-window t)
#+end_src

* Time optimization

Time optimization mostly means less clanking on keyboard to save time
for more productive activities.

** Shorter answers

Use single letters ~y~ or ~n~ for answers instead of complete words ~yes~ or ~no~.
A longer word was intended for cases where giving the wrong answer would
have serious consequences, but in reality with short answers you decide
how long a pause you need in order to realize what the question is about.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Don't spend time answering useless questions

Enable all disabled commands such as ~narrow-to-region~, etc.

#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src

* Most significant Emacs customizations
* Window management
* Efficient navigation in different modes and between buffers.
** Smart moves
** Lynx-like navigation in Info, Man, Dired, W3, W3M modes
* Disabled most of the default limitations.
* Improved many standard Emacs commands and modes.
* Added new functionality and new keybindings.

* Fixes for packages

When some package lacks necessary features that I need, and
I'm not sure if such functionality would be generally useful
to be added to that package, in this case I implement such a feature
in my init file that later could be adapted into a patch to submit
for the package to improve.

** battery

The built-in package ~battery~ doesn't provide an additional timer that
periodically would check if the laptop is not on AC power line, then
display battery status on the mode line.

#+begin_src emacs-lisp
(defvar my-battery-timer nil)
(when (and (require 'battery nil t)
           (bound-and-true-p battery-status-function)
           (functionp battery-status-function))
  (when (and (boundp 'my-battery-timer) (timerp  my-battery-timer))
    (cancel-timer my-battery-timer))
  (setq my-battery-timer
        ;; Check periodically if went off-line and
        ;; discharging battery needs to be displayed
        (run-at-time t 600 (lambda ()
                             (display-battery-mode
                              (if (member (cdr (assoc ?L (funcall battery-status-function)))
                                          '("AC" "on-line"))
                                  0 1))))))
#+end_src

* Other

** No blinking

Blinking cursors are distracting - turn blink OFF:
here ~(*) (*) (*)~ indicates how cursor blinks.

#+begin_src emacs-lisp
(and (fboundp 'blink-cursor-mode) (blink-cursor-mode (- (*) (*) (*))))
#+end_src

* Local Variables :noexport:

~time-stamp~ in these local variables specifies the format
of the property =DATE= at the beginning of this file, so that
on saving it is updated automatically.

- Local Variables:
- eval: (add-hook 'before-save-hook 'time-stamp nil t)
- time-stamp-start: "DATE: "
- time-stamp-format: "%:y-%02m-%02d"
- time-stamp-end: "$"
- time-stamp-line-limit: 15
- End:
