#+TITLE: .emacs --- Emacs init file
#+AUTHOR: Juri Linkov
#+EMAIL: juri@linkov.net
#+DATE: 2020-04-27
#+Version: GNU Emacs 28.0.50 (x86_64-pc-linux-gnu)
#+Keywords: dotemacs, init
#+HTML_link_home: http://www.linkov.net/emacs
#+HTML_head: <script type="text/javascript" src="load.js"></script>
#+InfoJS_opt: view:info toc:t
#+PROPERTY: header-args:emacs-lisp :lexical yes
#+LINK: bug https://debbugs.gnu.org/%s
#+OPTIONS: broken-links:mark author:t creator:t timestamp:t email:t toc:t

#+begin_quote
"/Show me your init file and I'll tell you who you are./" -- [[http://www.google.com/search?q=%22tell+you+who+you+are%22+intitle%3Aproverbs+site%3Awikiquote.org][old proverb]] slightly modified
#+end_quote

/Copyright (C) 1989-2020  Juri Linkov <juri@linkov.net>/

* Table of Content                                                      :TOC:

- [[#literate-programming][Literate programming]]
- [[#construction-kit][Construction Kit]]
- [[#space-time-optimization][Space-time optimization]]
  - [[#reposition-windows][Reposition windows]]
- [[#space-optimization][Space optimization]]
  - [[#remove-unused-display-elements][Remove unused display elements]]
  - [[#tabs-with-tab-bar-and-tab-lines][Tabs with tab-bar and tab-lines]]
  - [[#full-screen-emacs-desktop][Full-screen Emacs desktop]]
- [[#time-optimization][Time optimization]]
  - [[#window-navigation][Window navigation]]
  - [[#shorter-answers][Shorter answers]]
  - [[#dont-spend-time-answering-useless-questions][Don't spend time answering useless questions]]
  - [[#using-the-esc-key-as-a-cancel-key][Using the =ESC= key as a cancel key]]
  - [[#list-structural-editing][List structural editing]]
  - [[#efficient-navigation-in-different-modes][Efficient navigation in different modes]]
  - [[#recenter-windows][Recenter windows]]
- [[#useful-features][Useful features]]
  - [[#searchreplace][Search/Replace]]
  - [[#copy-paste][copy-paste]]
- [[#major-modes][Major modes]]
- [[#used-packages][Used packages]]
  - [[#org][org]]
- [[#fixes-for-packages][Fixes for packages]]
  - [[#fix-timer-in-battery][Fix timer in battery]]
  - [[#fix-inconsistency-in-motion-keys][Fix inconsistency in motion keys]]
  - [[#fix-isearch][Fix isearch]]
- [[#other][Other]]
  - [[#no-blinking][No blinking]]

* Literate programming

First of all, as you may already noticed, this file follows the paradigm
called [[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]].  It is a text document that has both of these features:

1. Weaving: it is rendered to HTML while displayed either on GitLab/GitHub
   or when exported to HTML;
2. Tangling: the same document is executed during Emacs loading.

One line of code that initiates loading is in the separate file [[file:init.el][init.el]].
This makes it the smallest =init.el= file possible, having metric of just 1 [[https://en.wikipedia.org/wiki/Source_lines_of_code][SLOC]].
The single line in =init.el= is the following:

#+begin_src emacs-lisp :tangle no
(org-babel-load-file (locate-file "README.org" load-path))
#+end_src

It exports source code from this file to the file =README.el=.
To support lexical binding, the output file should have the
~lexical-binding~ cookie in its header:

#+begin_src emacs-lisp
;;; .emacs --- Emacs init file  -*- lexical-binding: t; -*-
#+end_src

You can read more about details of weaving and tangling in [[https://www.gnu.org/software/emacs/manual/html_mono/org.html#Extracting-source-code][the Org manual]].

Using the same file =README.org= as an self-executable document
fits nicely into the definition of Emacs where Emacs is the
self-documenting editor, and this file is a self-documenting init file.

* Construction Kit

There are many different definitions what Emacs really is - some call it
Integrated Development Environment (IDE), some call it a Lisp machine, etc.
and all of them are right.  What definition would be more relevant in the
context of this configuration file is that Emacs not just an editor, but
the *Editor Construction Kit* - that means an editor creation system whose
blocks could be combined in infinitely many ways to build a completely new editor -
and not just an editor but anything possible: web browser, mail client, [[https://xkcd.com/378/][butterfly]]...
So Emacs is more like a UI framework.

And indeed, looking at different customizations, it's easy to notice that
none of them are like other editors based on the same Emacs core.
Their differences are so significant that it is hard to believe that they
come from the same source.

* Space-time optimization

While constructing an own editor, one of the most important goals is to
optimize it in both dimensions: in space and time.

Optimization of space means to make usage of screen space more optimal, and
optimization of time means to reduce time required to perform different tasks.

** Reposition windows

An example where both space and time is optimized is automatic reposition
of text in windows, so when text is automatically aligned, you don't need
to spend time scrolling the buffer backward/forward, and space is not wasted
for parts of the buffer that are not relevant to the task at hand.
One function that help to achieve optimal reposition is ~reposition-window~,
use it where possible in hooks that display a new location:

#+begin_src emacs-lisp
(defun my-reposition-window ()
  "Override default command that doesn't handle some modes."
  (if (memq major-mode '(fundamental-mode dired-mode))
      (recenter-top)
    (reposition-window)))

(add-hook 'next-error-hook 'my-reposition-window)
(add-hook 'xref-after-jump-hook 'my-reposition-window)
(add-hook 'xref-after-return-hook 'my-reposition-window)
(add-hook 'find-function-after-hook 'my-reposition-window)
#+end_src

* Space optimization

By default, Emacs looks like a typical GUI application with the menu bar,
tool bar, scroll bars, etc.  The problem is that these nice-looking UI
elements occupy precious screen real estate.  Some parts of this configuration
deal with this problem by reclaiming unused space to maximize information
density on the screen.

** Remove unused display elements

Get rid of all space-wasting garbage and minimize clutter.

#+begin_src emacs-lisp
(and (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(and (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(and (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
(and (fboundp 'tooltip-mode) (fboundp 'x-show-tip) (tooltip-mode -1))
#+end_src

** Tabs with tab-bar and tab-lines

Tabs introduced in Emacs 27 can be used without the tab-bar when
~tab-bar-show~ is customized to ~nil~.  Without the tab-bar you can switch
between tabs using completion on tab names, or using ~tab-switcher~ that is
like task switcher in some window managers invoked by =Alt+Tab=.

When the tab-bar is displayed, it's useful to show tab numbers,
to be able to select a tab by its ordinal number by typing e.g.
=s-1= to select the first tab, etc.

#+begin_src emacs-lisp
(setq tab-bar-tab-hints t
      tab-bar-select-tab-modifiers '(super))
#+end_src

By default, the tab shows the name of the current buffer, but I prefer
to show all buffer names in the tab name:

#+begin_src emacs-lisp
(setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
#+end_src

Whereas tab-bar and tab-lines still take screen space, they are sometimes
indispensable especially on devices with touch screen such as smartphones
where you can touch tabs to select them:

#+begin_src emacs-lisp
(when (fboundp 'tab-bar-mode) (tab-bar-mode 1))
(when (fboundp 'global-tab-line-mode) (global-tab-line-mode 1))
;; Allow selecting tabs in xterm on Android
(unless window-system (xterm-mouse-mode 1))
#+end_src

To make tab switching as quick as possible, this configuration uses
the key =`= located near the =TAB= key, so switching frames
with the help of a window manager is performed by =Alt+Tab=,
and switching tabs with window configurations is by =Alt+`=.
So you don't need to rely on mouse that is too slow UI device.
And this ~tab-switcher~ can be used even without the tab-bar.

After displaying a list of tabs, a previous tab can by selected
by one key =`=, the second tab by two keys =`=, etc.  Moving up
is by =Shift-`=, and selecting a previous tab is by =Alt+`=:

#+begin_src emacs-lisp
(when (featurep 'tab-bar)
  (define-key global-map [(meta     ?`)] 'tab-switcher)
  (define-key global-map [(super    ?`)] 'tab-switcher)
  (define-key global-map [(meta  ?\xa7)] 'tab-switcher)
  ;; (define-key global-map [(meta ?\x8a7)] 'tab-switcher)
  (with-eval-after-load 'tab-bar
    (define-key tab-switcher-mode-map [(meta     ?`)] 'tab-switcher-select)
    (define-key tab-switcher-mode-map [(super    ?`)] 'tab-switcher-select)
    (define-key tab-switcher-mode-map [(meta  ?\xa7)] 'tab-switcher-select)
    ;; (define-key tab-switcher-mode-map [(meta ?\x8a7)] 'tab-switcher-select)
    (define-key tab-switcher-mode-map [(    ?`)] 'tab-switcher-next-line)
    (define-key tab-switcher-mode-map [( ?\xa7)] 'tab-switcher-next-line)
    ;; (define-key tab-switcher-mode-map [(?\x8a7)] 'tab-switcher-next-line)
    (define-key tab-switcher-mode-map [(    ?~)] 'tab-switcher-prev-line)
    (define-key tab-switcher-mode-map [( ?\xbd)] 'tab-switcher-prev-line)
    ;; (define-key tab-switcher-mode-map [(?\x8bd)] 'tab-switcher-prev-line)
    ))
#+end_src

~tab-bar-history-mode~ is like ~winner-mode~ but replaces it
with the same keybindings when ~tab-bar-mode~ is enabled:

#+begin_src emacs-lisp
(when (fboundp 'tab-bar-history-mode) (tab-bar-history-mode 1))
(when tab-bar-history-mode
  (define-key global-map [(control c) left]  'tab-bar-history-back)
  (define-key global-map [(control c) right] 'tab-bar-history-forward))
#+end_src

** Full-screen Emacs desktop

To use maximum screen space, my Emacs frame covers the entire screen
and has no menus, no toolbars, no scrollbars, no title and no borders.
Such customization on 1024x768 display mode and 6x10 font produces
Emacs text screen resolution 168 columns x 75 lines.
~split-window-horizontally~ gives two windows with 83 columns x 75 lines.
And ~follow-mode~ displays one buffer with 83 columns x 150 lines.
On 1366x768 this gives 225 columns x 75 lines, this means either
2 horizontally split windows each 112 columns wide, or
3 horizontally split windows each 75 columns wide.

#+begin_src emacs-lisp
(cond
 ((eq window-system 'x)
  ;;(create-fontset-from-ascii-font "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-koi8-*")
  (create-fontset-from-ascii-font "-misc-fixed-medium-r-*--10-*-*-*-*-*-*-*")
  (setq default-frame-alist
        (append
         '(
           ;; A lot of different fonts were tried to pick the best one:
           ;;(font . "-*-*-medium-r-normal--10-*-*-*-c-60-fontset-koi8_r_10")
           ;;? (font . "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-koi8-*")
           ;;? (font . "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-*-*")
           ;; (font . "-misc-fixed-medium-r-normal--10-100-75-75-c-60-iso10646-1")
           ;; (font . "-*-*-medium-r-*--10-*-*-*-*-*-fontset-iso8859_1_10")
           ;; (font . "-misc-fixed-medium-r-normal--10-*-*-*-c-60-iso8859-1")
           ;; Unlike iso8859-1, iso10646-* correctly combines accented chars:
           (font . "-misc-fixed-medium-r-normal--10-*-*-*-c-60-iso10646-*")
           (cursor-type . bar)
           ;; To win a lot of screen pixels:
           (vertical-scroll-bars . nil)
           (horizontal-scroll-bars . nil)
           (scroll-bar-width . 0)
           (internal-border-width . 0)
           (menu-bar-lines . 0)
           (tool-bar-lines . 0)
           (line-spacing . 0))
         default-frame-alist))))
#+end_src

To make the Emacs frame truly maximized, we need additionally make it ~undecorated~
that removes any remaining window decorations including the title bar:

#+begin_src emacs-lisp
(add-hook 'after-make-frame-functions 'toggle-frame-maximized)
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (modify-frame-parameters frame '((undecorated . t)))
            ;; Some OS resources change background to grey, revert it back to white:
            (modify-frame-parameters frame '((background-color . "white")))
            ;; For some OS window managers that don't put focus to new frames:
            (select-frame-set-input-focus frame)))

;; Apply `undecorated' to new frames created by these commands:
(advice-add 'make-frame-on-monitor :around
            (lambda (orig-fun monitor &optional display parameters)
              (funcall orig-fun monitor display
                       (append '((undecorated . t)) parameters)))
            '((name . make-frame-on-monitor-undecorated)))

(advice-add 'make-frame-on-current-monitor :around
            (lambda (orig-fun &optional parameters)
              (funcall orig-fun (append '((undecorated . t)) parameters)))
            '((name . make-frame-on-current-monitor-undecorated)))

;; Undecorate the initial frame as well
(modify-frame-parameters nil '((undecorated . t)))
#+end_src

In earlier versions there was no way to unframe and maximize Emacs window from Emacs,
so it was necessary to use such code in =~/.sawfish/rc=:

#+begin_src lisp
(require 'sawfish.wm.state.maximize)
(define (my-customize-emacs-window w)
  (when (string-match "emacs" (nth 2 (get-x-property w 'WM_CLASS)))
    (window-put w 'type 'unframed)
    (maximize-window w)))
(add-hook 'before-add-window-hook my-customize-emacs-window t)
#+end_src

There are different ways to maximize initial frame after loading the init file:
=emacs -mm= that sets ~(setq initial-frame-alist '((fullscreen . maximized)))~
or ~(add-to-list 'default-frame-alist '(fullscreen . maximized))~
or ~(toggle-frame-maximized)~ or ~(set-frame-size (selected-frame) 210 80)~
(that works only in KDE).

Below is the only way that works reliably on GNU/Linux:

#+begin_src emacs-lisp
(add-hook 'after-init-hook
          (lambda ()
            (run-at-time
             "1 second" nil
             'shell-command-to-string   ; to not overwrite the echo area
             "wmctrl -r :ACTIVE: -b add,maximized_vert,maximized_horz")
            ;; Fix a recent bug that breaks frame dimensions after desktop frame restore:
            ;; I get a maximized frame visually, but internally with unmaximized dimensions,
            ;; i.e. mouse avoidance moves the mouse pointer to the middle of the frame
            ;; instead to the edges, etc.
            ;; (toggle-frame-maximized)
            ;; (toggle-frame-maximized)
            )
          t)
#+end_src

* Time optimization

Time optimization mostly means less clanking on keyboard to save time
for more productive activities.

** Window navigation

The fastest way to navigate between windows is by using directional keys
set by ~windmove~, so typing an arrow key will indicate the direction
where you want to move, e.g. =s-right= switches to the right window, etc.

With this configuration you can also type =s-M-right= to display the next
buffer in the right window, =C-x s-right= to delete the window on the right,
and =S-s-right= to swap the current buffer with the buffer in the right window.
Holding the =S-s-= keys and typing arrow keys will move windows up/down, left/right
like tiles in the [[https://en.wikipedia.org/wiki/15_puzzle][15-puzzle]]:

#+begin_src emacs-lisp
(windmove-default-keybindings 'super)
(windmove-display-default-keybindings '(super meta))
(windmove-delete-default-keybindings nil 'super)
(windmove-swap-states-default-keybindings '(shift super))
#+end_src

** Shorter answers

Use single letters =y= or =n= for answers instead of complete words =yes= or =no=.
A longer word was intended for cases where giving the wrong answer would
have serious consequences, but in reality with short answers you decide
how long a pause you need in order to realize what the question is about.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Don't spend time answering useless questions

Enable all disabled commands such as ~narrow-to-region~, etc.

#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src

** Using the =ESC= key as a cancel key

One of the biggest productivity boosts is making the =ESC= key
to get out of some modal states like it does in other programs
and what is the main purpose of this key according to its name
=ESCAPE=.

By default, in Emacs =ESC= is a useless duplicate of the =Meta= key
that doesn't work on consoles.  But it makes no sense on window systems
and text terminals where the =Meta= key works fine, so on a window system
there is no need to use =ESC= as a prefix key.  Use a single =[escape]= key
instead of knocking it 3 times:

#+begin_src emacs-lisp
(when window-system
  (define-key global-map [escape] 'keyboard-escape-quit)
  (define-key isearch-mode-map  [escape] 'isearch-cancel))
#+end_src

** List structural editing

This is my most frequently used DWIM command bound to =C-RET= in Lisp modes.
Since I don't use ~electric-indent-mode~, this is its less-obtrusive replacement
that does all the necessary things depending on context: indents the
current line, inserts a newline, and indents the next expression.

#+begin_src emacs-lisp
(defun my-reindent-then-newline-and-indent-and-indent-sexp ()
  "Reindent current line, insert newline, then indent the new line.
Move backward out of one level of parentheses.
Indent each line of the list starting just after point."
  (interactive "*")
  (reindent-then-newline-and-indent)
  (save-excursion
    (condition-case nil (backward-up-list) (error nil))
    (indent-sexp)))

(define-key emacs-lisp-mode-map [(control return)]
            'my-reindent-then-newline-and-indent-and-indent-sexp)
(define-key lisp-interaction-mode-map [(control return)]
            'my-reindent-then-newline-and-indent-and-indent-sexp)
(define-key lisp-mode-map [(control return)]
            'my-reindent-then-newline-and-indent-and-indent-sexp)
(with-eval-after-load 'scheme
  (define-key scheme-mode-map [(control return)]
    'my-reindent-then-newline-and-indent-and-indent-sexp))
#+end_src

This is another frequently used DWIM command bound to =C-backspace=.
It's almost the reverse of =C-RET= defined above: joins two lines
and indents the joined code.  IOW, both commands keep the indentation
always consistent.

#+begin_src emacs-lisp
(defun my-join-line-and-indent-sexp ()
  "Join this line to previous and fix up whitespace at join.
Move backward out of one level of parentheses.
Indent each line of the list starting just after point."
  (interactive "*")
  (join-line)
  (save-excursion
    (condition-case nil (backward-up-list) (error nil))
    (let ((indent-sexp-function (key-binding "\e\C-q")))
      (if indent-sexp-function (call-interactively indent-sexp-function)))))

(defun my-join-line-and-indent-sexp-or-backward-kill-word ()
  "If point is on the whitespaces at the beginning of a line,
then join this line to previous and indent each line of the upper list.
Otherwise, kill characters backward until encountering the end of a word."
  (interactive)
  (if (save-excursion (and (skip-chars-backward " \t") (bolp)))
      (my-join-line-and-indent-sexp)
    (backward-kill-word 1)))

;; Bind globally, not only in Lisp modes:
(global-set-key [C-backspace] 'my-join-line-and-indent-sexp-or-backward-kill-word)
;; (define-key lisp-mode-map [(control backspace)]
;;             'my-join-line-and-indent-sexp-or-backward-kill-word)
;; (define-key emacs-lisp-mode-map [(control backspace)]
;;             'my-join-line-and-indent-sexp-or-backward-kill-word)
;; (with-eval-after-load 'scheme
;;   (define-key scheme-mode-map [(control backspace)]
;;     'my-join-line-and-indent-sexp-or-backward-kill-word))
#+end_src

A smart version if completion is bound to =TAB= in Lisp modes:

#+begin_src emacs-lisp
(defun my-lisp-indent-or-complete (&optional arg)
  "Complete Lisp symbol, or indent line or region.
If the character preceding point is symbol-constituent, then perform
completion on Lisp symbol preceding point using `lisp-complete-symbol'.
Otherwise, call `indent-for-tab-command' that indents line or region."
  (interactive "P")
  (if (and (not (and transient-mark-mode mark-active
                     (not (eq (region-beginning) (region-end)))))
           (memq (char-syntax (preceding-char)) (list ?w ?_))
           (not (bobp)))
      (completion-at-point)
    (indent-for-tab-command arg)))

(define-key emacs-lisp-mode-map [tab] 'my-lisp-indent-or-complete)
#+end_src

A smarter jumping to the beginning of the line:

#+begin_src emacs-lisp
(defun my-beginning-of-line-or-indentation (arg)
  "Jump to the beginning of the line or to the indentation (like `M-m')."
  (interactive "^p")
  (if (bolp)
      (beginning-of-line-text arg) ; (back-to-indentation) ?
    (if (fboundp 'move-beginning-of-line)
        (move-beginning-of-line arg)
      (beginning-of-line arg))))

;; (put 'my-beginning-of-line-or-indentation 'isearch-move t)
(define-key global-map [(control ?a)] 'my-beginning-of-line-or-indentation)
#+end_src

This is a more general version that also handles numbered lists:

#+begin_src emacs-lisp
(defun my-reindent-then-newline-and-indent ()
  "Create the next number item in the numbered list, or reindent."
  (interactive)
  (let ((num 1))
    (if (save-excursion
          (backward-paragraph)
          (forward-line)
          (not (and (looking-at "^\\s-*\\([0-9]\\)\\.")
                    (setq num (match-string 1)))))
        (reindent-then-newline-and-indent)
      (insert (format "\n\n%s. " (1+ (string-to-number num)))))))

(define-key global-map [(control       return)] 'reindent-then-newline-and-indent)
(define-key global-map [(control shift return)] 'my-reindent-then-newline-and-indent)

(define-key global-map [S-return] 'electric-newline-and-maybe-indent)
#+end_src

** Efficient navigation in different modes

*** Lynx-like navigation in Info, Man, Dired, W3, W3M modes


** Recenter windows

Instead of the default behavior that recenters to the middle of the screen,
add customization that recenter to the middle of the top half of the screen
to reduce time spent for scrolling and adjusting the position of edited text:

#+begin_src emacs-lisp
(setq recenter-positions '(0.15 top)
      next-error-recenter 15
      compare-windows-recenter '(15 15))

(defvar my-recenter-position nil
  "Default recenter position.")

(when (boundp 'recenter-positions)
  (setq my-recenter-position (car recenter-positions)))

(defun recenter-top ()
  (interactive)
  (recenter (round (* my-recenter-position (window-height)))))
#+end_src

Let =C-M-a= (~beginning-of-defun~) not scroll the window
when after jumping point stays within current window bounds:

#+begin_src emacs-lisp
(advice-add 'beginning-of-defun :around
            (lambda (orig-fun &rest args)
              (let ((w-s (window-start))
                    (w-e (window-end)))
                (apply orig-fun args)
                (when (and
                       ;; Only when used interactively
                       (eq this-command 'beginning-of-defun)
                       ;; And only when jumping outside of window
                       ;; to the center of the window
                       (or (< (point) w-s) (> (point) w-e)))
                  (recenter-top))))
            '((name . recenter-top)))
#+end_src

* Useful features

** Copy/Paste

*** Select items from the kill-ring using the minibuffer history

Please read the docstring, it describes the command pretty well:

#+begin_src emacs-lisp
(defvar yank-from-kill-ring-history nil)
(defun yank-from-kill-ring (string)
  "Insert the kill-ring item selected from the minibuffer history.
Use minibuffer navigation and search commands to browse the kill-ring
in the minibuffer history before typing RET to insert the item."
  (interactive
   (list (let ((history-add-new-input nil)
               ;; Remove keymaps from text properties of copied string,
               ;; because typing RET in the minibuffer might call
               ;; an irrelevant command from the map of copied string.
               (yank-from-kill-ring-history
                (mapcar (lambda (h)
                          ;; TODO: remove all props except face/font-lock-face
                          (remove-list-of-text-properties
                           0 (length h)
                           '(
                             keymap local-map action mouse-action
                             button category help-args)
                           h)
                          h)
                        kill-ring)))
           (read-string "Yank from kill-ring: " nil 'yank-from-kill-ring-history))))
  (setq yank-window-start (window-start))
  (push-mark)
  (insert-for-yank string))

(global-set-key "\M-\C-y" 'yank-from-kill-ring)

(when delete-selection-mode
  (put 'yank-from-kill-ring 'delete-selection t))
#+end_src

*** Decode URL copied from web browser

It converts e.g. https://en.wikipedia.org/wiki/%CE%A9
to more nice-looking https://en.wikipedia.org/wiki/Ω
when copying a URL from a web browser to Emacs:

#+begin_src emacs-lisp
(advice-add 'gui-selection-value :around
            (lambda (orig-fun &rest args)
              (let ((value (apply orig-fun args)))
                (when (and (stringp value)
                           (string-match-p
                            (rx bos "http" (* nonl) "%" (* nonl) eos) value))
                  (setq value (decode-coding-string (url-unhex-string value) 'utf-8))
                  ;; Encode spaces back again because ffap/thing-at-point fail at spaces
                  (setq value (replace-regexp-in-string " " "%20" value)))
                value))
            '((name . gui-selection-value-url-decode)))
#+end_src

*** Copy text at point without activating the region

#+begin_src emacs-lisp
(defvar kill-ring-save-set-region-p nil)

;; When M-w (kill-ring-save) is called without active region, copy text at point.
(advice-add 'kill-ring-save :before
            (lambda (&rest _args)
              (interactive (lambda (spec)
                             (setq kill-ring-save-set-region-p nil)
                             (unless (use-region-p)
                               (let ((bounds (or (bounds-of-thing-at-point 'url)
                                                 (bounds-of-thing-at-point 'filename)
                                                 (bounds-of-thing-at-point 'symbol)
                                                 (bounds-of-thing-at-point 'sexp))))
                                 (unless bounds
                                   (signal 'mark-inactive nil))
                                 (goto-char (car bounds))
                                 (push-mark (cdr bounds) t t)
                                 (setq kill-ring-save-set-region-p t)))
                             (advice-eval-interactive-spec spec))))
            '((name . set-region-if-inactive)))

;; Indicate copied region, especially needed when
;; the region was activated by the advice above
(advice-add 'kill-ring-save :after
            (lambda (&rest _args)
              ;; When the region was set by the advice above,
              ;; only then display its text.
              (when kill-ring-save-set-region-p
                (let ((text (substring-no-properties (current-kill 0))))
                  (message "Copied text \"%s\""
                           (query-replace-descr ; don't show newlines literally
                            (if (> (length text) 64)
                                (concat (substring text 0 64) "..." (substring text -16))
                              text))))))
            '((name . indicate-copied-region)))
#+end_src

** Search/Replace

*** Enable new isearch features

The following features are new in Emacs 27:
1. Show match numbers in the search prompt;
2. Use =shift= key to pull text from the buffer to the search string;
3. Scroll off the screen while Isearch is still active:

#+begin_src emacs-lisp
(setq isearch-lazy-count t
      isearch-yank-on-move 'shift
      isearch-allow-scroll 'unlimited)
#+end_src

*** Smoother isearch navigation

Save and restore window start positions on returning back to previous search hit.
So when the next search hit is off the screen, then use ~reposition-window~
to fit the text unit as much as possible on the screen.  When the next search hit
is still on the same screen, don't scroll the screen to avoid shaking.
On returning to previous search results with the =DEL= key, restore exactly
the same screen state that was before.

#+begin_src emacs-lisp
;; TODO: try to use ‘add-function’
(setq isearch-push-state-function
      (lambda ()
        ;; Recenter new search hits outside of window boundaries
        (when (and isearch-success (not (pos-visible-in-window-p)))
          ;; reposition-window takes too much time in large buffers
          (if (or (memq major-mode '(fundamental-mode dired-mode))
                  (> (buffer-size) 1000000))
              (recenter-top)
            (condition-case nil
                ;; Prevent errors from reposition-window
                (reposition-window)
              (error nil))))
        `(lambda (cmd)
           (when isearch-success
             (set-window-start nil ,(window-start))))))

(defun isearch-refresh-state ()
  "Refresh the last search state.
This might be necessary when e.g. the window was manually recentered with
`C-l C-l', so new window-start should be updated in push-state-function above
before searching for the next hit."
  ;; Pop and discard the previous state
  (pop isearch-cmds)
  ;; Push a new state
  (isearch-push-state))

(advice-add 'isearch-repeat-forward :before
            (lambda (&rest _args)
              (isearch-refresh-state))
            '((name . refresh-state)))

(advice-add 'isearch-repeat-backward :before
            (lambda (&rest _args)
              (isearch-refresh-state))
            '((name . refresh-state)))
#+end_src

*** Useful isearch keys

In Emacs 27, ~isearch-beginning-of-buffer~ is bound to =M-s M-<=.
Bind it to the shorter key that doesn't exit Isearch:

#+begin_src emacs-lisp
(define-key isearch-mode-map "\M-<" 'isearch-beginning-of-buffer)
(define-key isearch-mode-map "\M->" 'isearch-end-of-buffer)

(define-key isearch-mode-map             "\t" 'isearch-complete)
(define-key minibuffer-local-isearch-map "\t" 'isearch-complete-edit)
#+end_src

*** Start isearch with text from the active region

Use key =M-s r= or =M-s M-.= to run Isearch and pull text from the active region
to the search string:

#+begin_src emacs-lisp
(defun isearch-forward-region ()
  "Do incremental search forward for text from the active region.
Like ordinary incremental search except that text from the region
is added to the search string initially if the region is active."
  (interactive)
  (isearch-forward nil 1)
  (cond
   ((use-region-p)
    (when (< (mark) (point))
      (exchange-point-and-mark))
    (isearch-yank-string
     (buffer-substring-no-properties (region-beginning) (region-end)))
    (deactivate-mark))
   (t
    (setq isearch-error "No active region")
    (isearch-push-state)
    (isearch-update))))

(define-key search-map "r"    'isearch-forward-region)
(define-key search-map "\M-." 'isearch-forward-region)
#+end_src

*** isearch-lazy-hints

I admit this could be a separate package:

#+begin_src emacs-lisp
(require 'seq)

(defcustom isearch-lazy-hints nil
  "Show numeric hints on isearch lazy-highlighted matches."
  :type 'boolean
  :group 'lazy-highlight)

(defface isearch-lazy-hint
  '((t :inherit lazy-highlight))
  "Face for lazy highlighting of counter hints."
  :group 'lazy-highlight
  :group 'basic-faces)

(defvar isearch-lazy-hints-overlays nil)

(defun isearch-lazy-hints-cleanup ()
  (while isearch-lazy-hints-overlays
    (delete-overlay (pop isearch-lazy-hints-overlays))))

(defun isearch-lazy-hint (pos count)
  (let* ((ov (make-overlay pos pos)
             ;; (if (or (and isearch-forward (> count 0))
             ;;         (and (not isearch-forward) (< count 0)))
             ;;     (make-overlay (1- pos) pos)
             ;;   (make-overlay pos (1+ pos)))
             )
         (hint (number-to-string count)))
    (set-text-properties 0 (length hint)
                         '(face isearch-lazy-hint
                           display ((height 0.7) (raise 0.3)))
                         hint)
    (overlay-put ov 'after-string hint)
    ;; (overlay-put ov 'display hint)
    (overlay-put ov 'priority 1000)
    (overlay-put ov 'window (selected-window))
    (push ov isearch-lazy-hints-overlays)))

(defun isearch-lazy-hints ()
  (when isearch-lazy-hints
    (isearch-lazy-hints-cleanup)
    (let* ((wgs (window-group-start))
           (wge (window-group-end))
           (p (or isearch-other-end (point)))
           (grouped-overlays
            (seq-group-by (lambda (ov)
                            (let* ((os (overlay-start ov))
                                   (oe (overlay-end   ov)))
                              (cond
                               ((or (< os wgs) (> oe wge)) nil)
                               ((> oe p) 'after)
                               (t 'before))))
                          isearch-lazy-highlight-overlays)))
      (seq-map-indexed
       (lambda (ov index)
         (isearch-lazy-hint (if isearch-forward (overlay-end ov) (overlay-start ov))
                            (1+ index)))
       (cdr
        ;; Skip the current match
        (seq-sort-by #'overlay-start (if isearch-forward #'< #'>)
                     (cdr (assq (if isearch-forward 'after 'before)
                                grouped-overlays)))))
      (seq-map-indexed
       (lambda (ov index)
         (isearch-lazy-hint (if isearch-forward (overlay-start ov) (overlay-end ov))
                            (- (1+ index))))
       (seq-sort-by #'overlay-start (if isearch-forward #'> #'<)
                    (cdr (assq (if isearch-forward 'before 'after)
                               grouped-overlays)))))))

(defun isearch-toggle-lazy-hints ()
  (interactive)
  (when isearch-lazy-hints
    (isearch-lazy-hints-cleanup))
  (setq isearch-lazy-hints (not isearch-lazy-hints))
  (when isearch-lazy-hints
    (isearch-lazy-hints)))

;; (add-hook 'isearch-mode-end-hook 'isearch-lazy-hints-cleanup)
;; To clean also after ispell lazy-highlight
(advice-add 'lazy-highlight-cleanup :after
            (lambda (&optional _force _procrastinate)
              (isearch-lazy-hints-cleanup)))

;; TODO: add to the end of isearch-lazy-highlight-new-loop
(add-hook 'isearch-update-post-hook 'isearch-lazy-hints)

;; TODO: call isearch-lazy-hint from isearch-lazy-highlight-update?
(advice-add 'isearch-lazy-highlight-update :after
            'isearch-lazy-hints)

(define-key isearch-mode-map (kbd "C-+") 'isearch-toggle-lazy-hints)
#+end_src

*** isearch-yank-until-char alike

This is like =M-z= (~zap-to-char~):

#+begin_src emacs-lisp
(defun skip-to-char (arg char)
  "Skip up to and including ARGth occurrence of CHAR.
Case is ignored if ‘case-fold-search’ is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "^p\ncSkip to char: ")
  (search-forward (char-to-string char) nil nil arg))
#+end_src

and it can be used in Isearch:

#+begin_src emacs-lisp
;; Allow `C-SPC C-M-z $ M-s M-.'
(define-key esc-map "\C-z" 'skip-to-char)
;; Allow `C-s C-M-z $' when `isearch-yank-on-move' is `t'
;; (put 'skip-to-char 'isearch-move t)
#+end_src

*** isearch-diff-hunk

Ignore diff-mode hunk indicators such as =+= or =-= at the
beginning of the diff lines while searching if the diff hunk
is unchanged.  For example, put the deleted hunk to the search string,
then search it for the next match, and it will find the hunk
moved to another part of the file:

#+begin_src emacs-lisp
(isearch-define-mode-toggle diff-hunk "+" diff-hunk-to-regexp "\
Ignore diff-mode hunk indicators such as `+' or `-' at bol.")

(defun diff-hunk-to-regexp (string &optional _lax _from)
  (replace-regexp-in-string
   "[[:space:]]+" "[[:space:]]+"
   (replace-regexp-in-string
    "^\\(\\\\\\+\\|-\\)" "\\(^\\)[+-]"
    (regexp-quote string) nil t)))

(add-hook 'diff-mode-hook
          (lambda ()
            (setq-local search-default-mode 'diff-hunk-to-regexp)))
#+end_src

*** Better isearch exiting

=C-RET= exits but doesn't add the current search string to the search ring.
Also moves point to the beginning of the found search string.

#+begin_src emacs-lisp
(define-key isearch-mode-map [(control return)] 'isearch-exit)

(add-hook 'isearch-mode-end-hook
          (lambda ()
            ;; Exiting isearch with C-RET
            (when (eq last-input-event 'C-return)
              ;; Move point to the beginning of the found search string
              (if (and isearch-forward isearch-other-end)
                  (goto-char isearch-other-end))
              ;; Don't add the current search string to the search ring
              (if isearch-regexp
                  (setq regexp-search-ring (cdr regexp-search-ring))
                (setq search-ring (cdr search-ring))))))
#+end_src

=S-RET= exits and leaves lazy-highlighted matches on the screen after exiting isearch.

#+begin_src emacs-lisp
(define-key isearch-mode-map [(shift return)]
                             'my-isearch-exit-leave-lazy-highlight)

(defun my-isearch-exit-leave-lazy-highlight ()
  "Exit search and leave extra match highlighting."
  (interactive)
  (let ((lazy-highlight-cleanup nil))
    (when isearch-lazy-highlight
      (isearch-lazy-highlight-new-loop (point-min) (point-max)))
    (isearch-exit)))
#+end_src

Note that to make the feature above more useful, you might want also
to enable highlighting all matches in the buffer, not only the portion
visible on the screen, then after exiting all matches in the buffer
remain highlighted:

#+begin_src emacs-lisp
(setq lazy-highlight-buffer t
      lazy-highlight-initial-delay 0
      lazy-highlight-max-at-a-time nil)
#+end_src

*** char-fold settings

Enable char-folding in isearch:

#+begin_src emacs-lisp
(setq search-default-mode #'char-fold-to-regexp)
#+end_src

and customize it:

#+begin_src emacs-lisp
(require 'char-fold)

(setq char-fold-symmetric t)

;; Allow search to match accented Cyrillic chars, so e.g. in etc/HELLO
;; “Здравствуйте” will match “Здра́вствуйте” and vice versa:
(setq char-fold-include
      (append char-fold-include
              '((?а "а́") (?А "А́")
                (?е "е́") (?Е "Е́")
                (?и "и́") (?И "И́")
                (?о "о́") (?О "О́")
                (?у "у́") (?У "У́")
                (?ы "ы́") (?Ы "Ы́")
                (?э "э́") (?Э "Э́")
                (?ю "ю́") (?Ю "Ю́")
                (?я "я́") (?Я "Я́"))))

;; Allow searching with Cyrillic translit
;; https://en.wikipedia.org/wiki/Transliteration
;; https://en.wikipedia.org/wiki/Romanization_of_Russian#Transliteration_table
(setq char-fold-include
      (append char-fold-include
              '((?а "a")
                (?б "b")
                (?в "v" "w")
                (?г "g")
                (?д "d")
                (?е "e")
                (?ё "jo" "yo")
                (?ж "v" "zh")
                (?з "z")
                (?и "i")
                (?й "j" "y")
                (?к "k")
                (?л "l")
                (?м "m")
                (?н "n")
                (?о "o")
                (?п "p")
                (?р "r")
                (?с "s")
                (?т "t")
                (?у "u")
                (?ф "f")
                (?х "h")
                (?ц "c")
                (?ч "ch")
                (?ш "sh")
                (?щ "sch")
                ;; (?ъ "")
                (?ы "y")
                ;; (?ь "")
                (?э "e")
                (?ю "ju" "yu")
                (?я "ja" "ya"))))

(char-fold-update-table)
#+end_src

*** text-property-search

Better interactive arguments for ~text-property-search-forward~ (see [[bug:36486]])

#+begin_src emacs-lisp
(defun search-text-property (property &optional value predicate not-current)
  "Same as `text-property-search-forward', but better interactive arguments.
Added support for reading the second argument VALUE that allows reading
symbols as well as strings.  Unlike `text-property-search-forward', this
command can find combined text properties, e.g. can find the property
`face' and the value `hi-yellow' in the buffer with the text property
containing the list of values `(hi-yellow font-lock-keyword-face)'.
Also ensure the whole buffer is fontified by `font-lock' to be able
to find all text properties with font-lock face."
  (interactive
   (let* ((property (completing-read "Search for property: " obarray
                                     nil nil nil nil '("markchars")))
          (property (when (> (length property) 0)
                      (intern property obarray)))
          (value (when property
                   (read-from-minibuffer "Search for property value (quote strings): "
                                         nil nil t nil '("nil" "confusable")))))
     (list property value)))
  (font-lock-ensure)
  (text-property-search-forward property value
                                (or predicate
                                    (lambda (val p-val)
                                      (if (and (listp p-val) (not (listp val)))
                                          (member val p-val)
                                        (equal val p-val))))
                                not-current))
#+end_src

*** occur

Make the =*Occur*= buffer names unique and writable
(like in ~compilation-mode-hook~ the this file).

#+begin_src emacs-lisp
(add-hook 'occur-hook
          (lambda ()
            (occur-rename-buffer t)
            (setq buffer-read-only nil)))

;; Based on `occur-mode-goto-occurrence-other-window'
(defun occur-mode-goto-occurrence-kill-buffer ()
  "Go to the occurrence the current line describes, and kill the Occur buffer."
  (interactive)
  (let ((buf (current-buffer))
        (pos (occur-mode-find-occurrence)))
    (switch-to-buffer-other-window (marker-buffer pos))
    (goto-char pos)
    (kill-buffer buf)
    (run-hooks 'occur-mode-find-occurrence-hook)))

;; Bind to "o" in place of `occur-mode-goto-occurrence'.
(define-key occur-mode-map [(control return)] 'occur-mode-goto-occurrence-kill-buffer)
#+end_src

*** replace

#+begin_src emacs-lisp
(defun substitute-regexp (substitution)
  "Use s/old/new/g regexp syntax for `query-replace'."
  (interactive
   (list
    (read-from-minibuffer "Substitute regexp: " '("s///g" . 3) nil nil
                          'query-replace-history nil t)))
  (if (string-match "\\`s/\\(.*\\)/\\(.*\\)/\\([gi]*\\)" substitution)
      (let* ((sregex (match-string 1 substitution))
             (ssubst (match-string 2 substitution))
             (sflags (match-string 3 substitution))
             (case-fold-search (string-match "i" sflags)))
        (perform-replace
         sregex ssubst (string-match "g" sflags)
         t nil nil nil
         (if (and transient-mark-mode mark-active) (region-beginning))
         (if (and transient-mark-mode mark-active) (region-end))))
    (error "Invalid syntax")))

;; FROM my answer in https://emacs.stackexchange.com/questions/27135/search-replace-like-feature-for-swapping-text/27170#27170
(defun query-swap-strings (from-string to-string &optional delimited start end backward region-noncontiguous-p)
  "Swap occurrences of FROM-STRING and TO-STRING."
  (interactive
   (let ((common
          (query-replace-read-args
           (concat "Query swap"
                   (if current-prefix-arg
                       (if (eq current-prefix-arg '-) " backward" " word")
                     "")
                   (if (use-region-p) " in region" ""))
           nil)))
     (list (nth 0 common) (nth 1 common) (nth 2 common)
           (if (use-region-p) (region-beginning))
           (if (use-region-p) (region-end))
           (nth 3 common)
           (if (use-region-p) (region-noncontiguous-p)))))
  (perform-replace
   (concat "\\(" (regexp-quote from-string) "\\)\\|" (regexp-quote to-string))
   `(replace-eval-replacement replace-quote (if (match-string 1) ,to-string ,from-string))
   t t delimited nil nil start end backward region-noncontiguous-p))
#+end_src

* Major modes

For a new non-file buffer set its major mode based on the buffer name.
For example, =C-x b newbuffer.el= will set the major mode in a new buffer
to ~emacs-lisp-mode~ by the file extension =.el= in the buffer name.

#+begin_src emacs-lisp
(setq-default major-mode (lambda ()
                           (if buffer-file-name
                               (fundamental-mode)
                             (let ((buffer-file-name (buffer-name)))
                               (set-auto-mode)))))
#+end_src

Note that this has some problems, e.g. in =autoinsert.el= that uses
~(eq major-mode (default-value 'major-mode))~.

* Used packages

#+begin_src emacs-lisp
(require 'package)
(setq package-enable-at-startup nil)
(unless (assoc "melpa" package-archives)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
(unless package--initialized
  (package-initialize))
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package t))
(eval-when-compile
  (require 'use-package))
(setq use-package-always-ensure t)
#+end_src

** org

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil
      org-src-fontify-natively t
      org-src-tab-acts-natively t)

(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+end_src

* Fixes for packages

When some package lacks necessary features that I need, and
I'm not sure if such functionality would be generally useful
to be added to that package, in this case I implement such a feature
in my init file that later could be adapted into a patch to submit
for the package to improve.

** Fix timer in battery

The built-in package =battery= doesn't provide an additional timer that
periodically would check if the laptop is not on AC power line, then
display battery status on the mode line.

#+begin_src emacs-lisp
(defvar my-battery-timer nil)
(when (and (require 'battery nil t)
           (bound-and-true-p battery-status-function)
           (functionp battery-status-function))
  (when (and (boundp 'my-battery-timer) (timerp  my-battery-timer))
    (cancel-timer my-battery-timer))
  (setq my-battery-timer
        ;; Check periodically if went off-line and
        ;; discharging battery needs to be displayed
        (run-at-time t 600 (lambda ()
                             (display-battery-mode
                              (if (member (cdr (assoc ?L (funcall battery-status-function)))
                                          '("AC" "on-line"))
                                  0 1))))))
#+end_src

** Fix inconsistency in motion keys

There was no symmetry for sexp like in =right-char= / =left-char=
and =right-word= / =left-word= ([[bug:36923]])

#+begin_src emacs-lisp
(defun right-sexp (&optional arg)
  "Move across one balanced expression (sexp) to the right.
Depending on the bidirectional context, this may move either forward
or backward in the buffer.  See more at `forward-sexp'."
  (interactive "^p")
  (if (eq (current-bidi-paragraph-direction) 'left-to-right)
      (forward-sexp arg)
    (backward-sexp arg)))

(defun left-sexp (&optional arg)
  "Move across one balanced expression (sexp) to the left.
Depending on the bidirectional context, this may move either backward
or forward in the buffer.  See more at `backward-sexp'."
  (interactive "^p")
  (if (eq (current-bidi-paragraph-direction) 'left-to-right)
      (backward-sexp arg)
    (forward-sexp arg)))

(define-key global-map [(control left)]       'left-sexp)
(define-key global-map [(control right)]      'right-sexp)
(define-key global-map [(control kp-left)]    'left-sexp)
(define-key global-map [(control kp-right)]   'right-sexp)
(define-key global-map [(control meta left)]  'left-word)
(define-key global-map [(control meta right)] 'right-word)
(define-key global-map [(control meta up)]    'backward-paragraph)
(define-key global-map [(control meta down)]  'forward-paragraph)
#+end_src

Fix controversial keybindings added in Emacs 23:

#+begin_src emacs-lisp
(define-key global-map [home] 'beginning-of-visual-line)
(define-key global-map [end]  'end-of-visual-line)
(define-key global-map [up]   'previous-line)
(define-key global-map [down] 'next-line)
#+end_src

Fix ~compare-windows~:

#+begin_src emacs-lisp
(define-key global-map [(control ?=)] 'compare-windows)
;; alternative: (lambda () (interactive) (compare-windows t))

;; I often mistype `compare-windows' as `comapre-windows', allow both:
(defalias 'comapre-windows 'compare-windows)
#+end_src

** Fix isearch

Set ~isearch-scroll~ on some commands:

#+begin_src emacs-lisp
(put 'narrow-to-defun 'isearch-scroll t)
(put 'widen 'isearch-scroll t)
(put 'toggle-truncate-lines 'isearch-scroll t)
(put 'comint-show-output 'isearch-scroll t) ;; bound to `C-M-l'

;; Mostly for `C-s M-s o'
(put 'windmove-display-up    'isearch-scroll t)
(put 'windmove-display-down  'isearch-scroll t)
(put 'windmove-display-left  'isearch-scroll t)
(put 'windmove-display-right 'isearch-scroll t)
#+end_src

* Other

** No blinking

Blinking cursors are distracting - turn blink OFF:
here =(*) (*) (*)= indicates how cursor blinks.

#+begin_src emacs-lisp
(and (fboundp 'blink-cursor-mode) (blink-cursor-mode (- (*) (*) (*))))
#+end_src

* Local Variables :noexport:

~time-stamp~ in these local variables specifies the format
of the property =DATE= at the beginning of this file, so that
on saving it is updated automatically.

- Local Variables:
- eval: (add-hook 'before-save-hook 'time-stamp nil t)
- time-stamp-start: "DATE: "
- time-stamp-format: "%:y-%02m-%02d"
- time-stamp-end: "$"
- time-stamp-line-limit: 15
- End:
