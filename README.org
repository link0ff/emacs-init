#+TITLE: .emacs --- Emacs init file
#+AUTHOR: Juri Linkov
#+EMAIL: juri@linkov.net
#+DATE: 2020-04-23
#+Version: GNU Emacs 28.0.50 (x86_64-pc-linux-gnu)
#+Keywords: dotemacs, init
#+HTML_link_home: http://www.linkov.net/emacs
#+HTML_head: <script type="text/javascript" src="load.js"></script>
#+InfoJS_opt: view:info toc:t
#+PROPERTY: header-args:emacs-lisp :lexical yes
#+LINK: bug https://debbugs.gnu.org/%s
#+OPTIONS: broken-links:mark author:t creator:t timestamp:t email:t toc:t

#+begin_quote
"/Show me your init file and I'll tell you who you are./" -- [[http://www.google.com/search?q=%22tell+you+who+you+are%22+intitle%3Aproverbs+site%3Awikiquote.org][old proverb]] slightly modified
#+end_quote

/Copyright (C) 1989-2020  Juri Linkov <juri@linkov.net>/

* Table of Content                                                      :TOC:

- [[#literate-programming][Literate programming]]
- [[#construction-kit][Construction Kit]]
- [[#space-time-optimization][Space-time optimization]]
  - [[#reposition-windows][Reposition windows]]
- [[#space-optimization][Space optimization]]
  - [[#remove-unused-display-elements][Remove unused display elements]]
  - [[#tabs-with-tab-bar-and-tab-lines][Tabs with tab-bar and tab-lines]]
  - [[#full-screen-emacs-desktop][Full-screen Emacs desktop]]
- [[#time-optimization][Time optimization]]
  - [[#window-navigation][Window navigation]]
  - [[#recenter-windows][Recenter windows]]
  - [[#shorter-answers][Shorter answers]]
  - [[#dont-spend-time-answering-useless-questions][Don't spend time answering useless questions]]
- [[#fixes-for-packages][Fixes for packages]]
  - [[#battery][battery]]
- [[#other][Other]]
  - [[#no-blinking][No blinking]]

* Literate programming

First of all, as you may already noticed, this file follows the paradigm
called [[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]].  It is a text document that has both of these features:

1. Weaving: it is rendered to HTML while displayed either on GitLab/GitHub
   or when exported to HTML;
2. Tangling: the same document is executed during Emacs loading.

One line of code that initiates loading is in the separate file [[file:init.el][init.el]].
This makes it the smallest ~init.el~ file possible, having metric of just 1 [[https://en.wikipedia.org/wiki/Source_lines_of_code][SLOC]].
The single line in ~init.el~ is the following:

#+begin_src emacs-lisp :tangle no
(org-babel-load-file (locate-file "README.org" load-path))
#+end_src

It exports source code from this file to the file ~README.el~.
To support lexical binding, the output file should have the
~lexical-binding~ cookie in its header:

#+begin_src emacs-lisp
;;; .emacs --- Emacs init file  -*- lexical-binding: t; -*-
#+end_src

You can read more about details of weaving and tangling in [[https://www.gnu.org/software/emacs/manual/html_mono/org.html#Extracting-source-code][the Org manual]].

Using the same file ~README.org~ as an self-executable document
fits nicely into the definition of Emacs where Emacs is the
self-documenting editor, and this file is a self-documenting init file.

* Construction Kit

There are many different definitions what Emacs really is - some call it
Integrated Development Environment (IDE), some call it a Lisp machine, etc.
and all of them are right.  What definition would be more relevant in the
context of this configuration file is that Emacs not just an editor, but
the *Editor Construction Kit* - that means an editor creation system whose
blocks could be combined in infinitely many ways to build a completely new editor -
and not just an editor but anything possible: web browser, mail client, [[https://xkcd.com/378/][butterfly]]...
So Emacs is more like a UI framework.

And indeed, looking at different customizations, it's easy to notice that
none of them are like other editors based on the same Emacs core.
Their differences are so significant that it is hard to believe that they
come from the same source.

* Space-time optimization

While constructing an own editor, one of the most important goals is to
optimize it in both dimensions: in space and time.

Optimization of space means to make usage of screen space more optimal, and
optimization of time means to reduce time required to perform different tasks.

** Reposition windows

An example where both space and time is optimized is automatic reposition
of text in windows, so when text is automatically aligned, you don't need
to spend time scrolling the buffer backward/forward, and space is not wasted
for parts of the buffer that are not relevant to the task at hand.
One function that help to achieve optimal reposition is ~reposition-window~,
use it where possible in hooks that display a new location:

#+begin_src emacs-lisp
(add-hook 'next-error-hook 'reposition-window)
(add-hook 'xref-after-jump-hook 'reposition-window)
(add-hook 'xref-after-return-hook 'reposition-window)
(add-hook 'find-function-after-hook 'reposition-window)
#+end_src

* Space optimization

By default, Emacs looks like a typical GUI application with the menu bar,
tool bar, scroll bars, etc.  The problem is that these nice-looking UI
elements occupy precious screen real estate.  Some parts of this configuration
deal with this problem by reclaiming unused space to maximize information
density on the screen.

** Remove unused display elements

Get rid of all space-wasting garbage and minimize clutter.

#+begin_src emacs-lisp
(and (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(and (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(and (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
(and (fboundp 'tooltip-mode) (fboundp 'x-show-tip) (tooltip-mode -1))
#+end_src

** Tabs with tab-bar and tab-lines

Tabs introduced in Emacs 27 can be used without the tab-bar when
~tab-bar-show~ is customized to ~nil~.  Without the tab-bar you can switch
between tabs using completion on tab names, or using ~tab-switcher~ that is
like task switcher in some window managers invoked by =Alt+Tab=.

When the tab-bar is displayed, it's useful to show tab numbers,
to be able to select a tab by its ordinal number by typing e.g.
=s-1= to select the first tab, etc.

#+begin_src emacs-lisp
(setq tab-bar-tab-hints t
      tab-bar-select-tab-modifiers '(super))
#+end_src

By default, the tab shows the name of the current buffer, but I prefer
to show all buffer names in the tab name:

#+begin_src emacs-lisp
(setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
#+end_src

Whereas tab-bar and tab-lines still take screen space, they are sometimes
indispensable especially on devices with touch screen such as smartphones
where you can touch tabs to select them:

#+begin_src emacs-lisp
(when (fboundp 'tab-bar-mode) (tab-bar-mode 1))
(when (fboundp 'global-tab-line-mode) (global-tab-line-mode 1))
;; Allow selecting tabs in xterm on Android
(unless window-system (xterm-mouse-mode 1))
#+end_src

To make tab switching as quick as possible, this configuration uses
the key =`= located near the =TAB= key, so switching frames
with the help of a window manager is performed by =Alt+Tab=,
and switching tabs with window configurations is by =Alt+`=.
So you don't need to rely on mouse that is too slow UI device.
And this ~tab-switcher~ can be used even without the tab-bar.

After displaying a list of tabs, a previous tab can by selected
by one key =`=, the second tab by two keys =`=, etc.  Moving up
is by =Shift-`=, and selecting a previous tab is by =Alt+`=:

#+begin_src emacs-lisp
(when (featurep 'tab-bar)
  (define-key global-map [(meta     ?`)] 'tab-switcher)
  (define-key global-map [(super    ?`)] 'tab-switcher)
  (define-key global-map [(meta  ?\xa7)] 'tab-switcher)
  ;; (define-key global-map [(meta ?\x8a7)] 'tab-switcher)
  (with-eval-after-load 'tab-bar
    (define-key tab-switcher-mode-map [(meta     ?`)] 'tab-switcher-select)
    (define-key tab-switcher-mode-map [(super    ?`)] 'tab-switcher-select)
    (define-key tab-switcher-mode-map [(meta  ?\xa7)] 'tab-switcher-select)
    ;; (define-key tab-switcher-mode-map [(meta ?\x8a7)] 'tab-switcher-select)
    (define-key tab-switcher-mode-map [(    ?`)] 'tab-switcher-next-line)
    (define-key tab-switcher-mode-map [( ?\xa7)] 'tab-switcher-next-line)
    ;; (define-key tab-switcher-mode-map [(?\x8a7)] 'tab-switcher-next-line)
    (define-key tab-switcher-mode-map [(    ?~)] 'tab-switcher-prev-line)
    (define-key tab-switcher-mode-map [( ?\xbd)] 'tab-switcher-prev-line)
    ;; (define-key tab-switcher-mode-map [(?\x8bd)] 'tab-switcher-prev-line)
    ))
#+end_src

~tab-bar-history-mode~ is like ~winner-mode~ but replaces it
with the same keybindings when ~tab-bar-mode~ is enabled:

#+begin_src emacs-lisp
(when (fboundp 'tab-bar-history-mode) (tab-bar-history-mode 1))
(when tab-bar-history-mode
  (define-key global-map [(control c) left]  'tab-bar-history-back)
  (define-key global-map [(control c) right] 'tab-bar-history-forward))
#+end_src

** Full-screen Emacs desktop

To use maximum screen space, my Emacs frame covers the entire screen
and has no menus, no toolbars, no scrollbars, no title and no borders.
Such customization on 1024x768 display mode and 6x10 font produces
Emacs text screen resolution 168 columns x 75 lines.
~split-window-horizontally~ gives two windows with 83 columns x 75 lines.
And ~follow-mode~ displays one buffer with 83 columns x 150 lines.
On 1366x768 this gives 225 columns x 75 lines, this means either
2 horizontally split windows each 112 columns wide, or
3 horizontally split windows each 75 columns wide.

#+begin_src emacs-lisp
(cond
 ((eq window-system 'x)
  ;;(create-fontset-from-ascii-font "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-koi8-*")
  (create-fontset-from-ascii-font "-misc-fixed-medium-r-*--10-*-*-*-*-*-*-*")
  (setq default-frame-alist
        (append
         '(
           ;; A lot of different fonts were tried to pick the best one:
           ;;(font . "-*-*-medium-r-normal--10-*-*-*-c-60-fontset-koi8_r_10")
           ;;? (font . "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-koi8-*")
           ;;? (font . "-rfx-fixed-medium-r-normal--10-*-*-*-c-60-*-*")
           ;; (font . "-misc-fixed-medium-r-normal--10-100-75-75-c-60-iso10646-1")
           ;; (font . "-*-*-medium-r-*--10-*-*-*-*-*-fontset-iso8859_1_10")
           ;; (font . "-misc-fixed-medium-r-normal--10-*-*-*-c-60-iso8859-1")
           ;; Unlike iso8859-1, iso10646-* correctly combines accented chars:
           (font . "-misc-fixed-medium-r-normal--10-*-*-*-c-60-iso10646-*")
           (cursor-type . bar)
           ;; To win a lot of screen pixels:
           (vertical-scroll-bars . nil)
           (horizontal-scroll-bars . nil)
           (scroll-bar-width . 0)
           (internal-border-width . 0)
           (menu-bar-lines . 0)
           (tool-bar-lines . 0)
           (line-spacing . 0))
         default-frame-alist))))
#+end_src

To make the Emacs frame truly maximized, we need additionally make it ~undecorated~
that removes any remaining window decorations including the title bar:

#+begin_src emacs-lisp
(add-hook 'after-make-frame-functions 'toggle-frame-maximized)
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (modify-frame-parameters frame '((undecorated . t)))
            ;; Some OS resources change background to grey, revert it back to white:
            (modify-frame-parameters frame '((background-color . "white")))
            ;; For some OS window managers that don't put focus to new frames:
            (select-frame-set-input-focus frame)))

;; Apply `undecorated' to new frames created by these commands:
(advice-add 'make-frame-on-monitor :around
            (lambda (orig-fun monitor &optional display parameters)
              (funcall orig-fun monitor display
                       (append '((undecorated . t)) parameters)))
            '((name . make-frame-on-monitor-undecorated)))

(advice-add 'make-frame-on-current-monitor :around
            (lambda (orig-fun &optional parameters)
              (funcall orig-fun (append '((undecorated . t)) parameters)))
            '((name . make-frame-on-current-monitor-undecorated)))

;; Undecorate the initial frame as well
(modify-frame-parameters nil '((undecorated . t)))
#+end_src

In earlier versions there was no way to unframe and maximize Emacs window from Emacs,
so it was necessary to use such code in =~/.sawfish/rc=:

#+begin_src lisp
(require 'sawfish.wm.state.maximize)
(define (my-customize-emacs-window w)
  (when (string-match "emacs" (nth 2 (get-x-property w 'WM_CLASS)))
    (window-put w 'type 'unframed)
    (maximize-window w)))
(add-hook 'before-add-window-hook my-customize-emacs-window t)
#+end_src

There are different ways to maximize initial frame after loading the init file:
=emacs -mm= that sets ~(setq initial-frame-alist '((fullscreen . maximized)))~
or ~(add-to-list 'default-frame-alist '(fullscreen . maximized))~
or ~(toggle-frame-maximized)~ or ~(set-frame-size (selected-frame) 210 80)~
(that works only in KDE).

Below is the only way that works reliably on GNU/Linux:

#+begin_src emacs-lisp
(add-hook 'after-init-hook
          (lambda ()
            (run-at-time
             "1 second" nil
             'shell-command-to-string   ; to not overwrite the echo area
             "wmctrl -r :ACTIVE: -b add,maximized_vert,maximized_horz")
            ;; Fix a recent bug that breaks frame dimensions after desktop frame restore:
            ;; I get a maximized frame visually, but internally with unmaximized dimensions,
            ;; i.e. mouse avoidance moves the mouse pointer to the middle of the frame
            ;; instead to the edges, etc.
            ;; (toggle-frame-maximized)
            ;; (toggle-frame-maximized)
            )
          t)
#+end_src

* Time optimization

Time optimization mostly means less clanking on keyboard to save time
for more productive activities.

** Window navigation

The fastest way to navigate between windows is by using directional keys
set by ~windmove~, so typing an arrow key will indicate the direction
where you want to move, e.g. =s-right= switches to the right window, etc.

With this configuration you can also type =s-M-right= to display the next
buffer in the right window, =C-x s-right= to delete the window on the right,
and =S-s-right= to swap the current buffer with the buffer in the right window.
Holding the =S-s-= keys and typing arrow keys will move windows up/down, left/right
like tiles in the [[https://en.wikipedia.org/wiki/15_puzzle][15-puzzle]]:

#+begin_src emacs-lisp
(windmove-default-keybindings 'super)
(windmove-display-default-keybindings '(super meta))
(windmove-delete-default-keybindings nil 'super)
(windmove-swap-states-default-keybindings '(shift super))
#+end_src

** Shorter answers

Use single letters ~y~ or ~n~ for answers instead of complete words ~yes~ or ~no~.
A longer word was intended for cases where giving the wrong answer would
have serious consequences, but in reality with short answers you decide
how long a pause you need in order to realize what the question is about.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Don't spend time answering useless questions

Enable all disabled commands such as ~narrow-to-region~, etc.

#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src

** Recenter windows

Instead of the default behavior that recenters to the middle of the screen,
add customization that recenter to the middle of the top half of the screen:

#+begin_src emacs-lisp
(setq recenter-positions '(0.15 top)
      next-error-recenter 15
      compare-windows-recenter '(15 15))

(defvar my-recenter-position nil
  "Default recenter position.")

(when (boundp 'recenter-positions)
  (setq my-recenter-position (car recenter-positions)))

(defun recenter-top ()
  (interactive)
  (recenter (round (* my-recenter-position (window-height)))))
#+end_src

Let =C-M-a= (~beginning-of-defun~) not scroll the window
when after jumping point stays within current window bounds:

#+begin_src emacs-lisp
(advice-add 'beginning-of-defun :around
            (lambda (orig-fun &rest args)
              (let ((w-s (window-start))
                    (w-e (window-end)))
                (apply orig-fun args)
                (when (and
                       ;; Only when used interactively
                       (eq this-command 'beginning-of-defun)
                       ;; And only when jumping outside of window
                       ;; to the center of the window
                       (or (< (point) w-s) (> (point) w-e)))
                  (recenter-top))))
            '((name . recenter-top)))
#+end_src

* Useful features

** copy-paste

*** Select items from the kill-ring using the minibuffer history

Please read the docstring, it describes the command pretty well:

#+begin_src emacs-lisp
(defvar yank-from-kill-ring-history nil)
(defun yank-from-kill-ring (string)
  "Insert the kill-ring item selected from the minibuffer history.
Use minibuffer navigation and search commands to browse the kill-ring
in the minibuffer history before typing RET to insert the item."
  (interactive
   (list (let ((history-add-new-input nil)
               ;; Remove keymaps from text properties of copied string,
               ;; because typing RET in the minibuffer might call
               ;; an irrelevant command from the map of copied string.
               (yank-from-kill-ring-history
                (mapcar (lambda (h)
                          ;; TODO: remove all props except face/font-lock-face
                          (remove-list-of-text-properties
                           0 (length h)
                           '(
                             keymap local-map action mouse-action
                             button category help-args)
                           h)
                          h)
                        kill-ring)))
           (read-string "Yank from kill-ring: " nil 'yank-from-kill-ring-history))))
  (setq yank-window-start (window-start))
  (push-mark)
  (insert-for-yank string))

(global-set-key "\M-\C-y" 'yank-from-kill-ring)

(when delete-selection-mode
  (put 'yank-from-kill-ring 'delete-selection t))
#+end_src

*** Decode URL copied from web browser

It converts e.g. https://en.wikipedia.org/wiki/%CE%A9
to more nice-looking https://en.wikipedia.org/wiki/Î©
when copying a URL from a web browser to Emacs:

#+begin_src emacs-lisp
(advice-add 'gui-selection-value :around
            (lambda (orig-fun &rest args)
              (let ((value (apply orig-fun args)))
                (when (and (stringp value)
                           (string-match-p
                            (rx bos "http" (* nonl) "%" (* nonl) eos) value))
                  (setq value (decode-coding-string (url-unhex-string value) 'utf-8))
                  ;; Encode spaces back again because ffap/thing-at-point fail at spaces
                  (setq value (replace-regexp-in-string " " "%20" value)))
                value))
            '((name . gui-selection-value-url-decode)))
#+end_src

*** Copy text at point without activating the region

#+begin_src emacs-lisp
(defvar kill-ring-save-set-region-p nil)

;; When M-w (kill-ring-save) is called without active region, copy text at point.
(advice-add 'kill-ring-save :before
            (lambda (&rest _args)
              (interactive (lambda (spec)
                             (setq kill-ring-save-set-region-p nil)
                             (unless (use-region-p)
                               (let ((bounds (or (bounds-of-thing-at-point 'url)
                                                 (bounds-of-thing-at-point 'filename)
                                                 (bounds-of-thing-at-point 'symbol)
                                                 (bounds-of-thing-at-point 'sexp))))
                                 (unless bounds
                                   (signal 'mark-inactive nil))
                                 (goto-char (car bounds))
                                 (push-mark (cdr bounds) t t)
                                 (setq kill-ring-save-set-region-p t)))
                             (advice-eval-interactive-spec spec))))
            '((name . set-region-if-inactive)))

;; Indicate copied region, especially needed when
;; the region was activated by the advice above
(advice-add 'kill-ring-save :after
            (lambda (&rest _args)
              ;; When the region was set by the advice above,
              ;; only then display its text.
              (when kill-ring-save-set-region-p
                (let ((text (substring-no-properties (current-kill 0))))
                  (message "Copied text \"%s\""
                           (query-replace-descr ; don't show newlines literally
                            (if (> (length text) 64)
                                (concat (substring text 0 64) "..." (substring text -16))
                              text))))))
            '((name . indicate-copied-region)))
#+end_src

* Most significant Emacs customizations
* Window management
* Efficient navigation in different modes and between buffers.
** Smart moves
** Lynx-like navigation in Info, Man, Dired, W3, W3M modes
* Disabled most of the default limitations.
* Improved many standard Emacs commands and modes.
* Added new functionality and new keybindings.



* Major modes

For a new non-file buffer set its major mode based on the buffer name.
For example, =C-x b newbuffer.el= will set the major mode in a new buffer
to ~emacs-lisp-mode~ by the file extension =.el= in the buffer name.

#+begin_src emacs-lisp
(setq-default major-mode (lambda ()
                           (if buffer-file-name
                               (fundamental-mode)
                             (let ((buffer-file-name (buffer-name)))
                               (set-auto-mode)))))
#+end_src

Note that this has some problems, e.g. in =autoinsert.el= that uses
~(eq major-mode (default-value 'major-mode))~.

* Fixes for packages

When some package lacks necessary features that I need, and
I'm not sure if such functionality would be generally useful
to be added to that package, in this case I implement such a feature
in my init file that later could be adapted into a patch to submit
for the package to improve.

** Fix timer in battery

The built-in package ~battery~ doesn't provide an additional timer that
periodically would check if the laptop is not on AC power line, then
display battery status on the mode line.

#+begin_src emacs-lisp
(defvar my-battery-timer nil)
(when (and (require 'battery nil t)
           (bound-and-true-p battery-status-function)
           (functionp battery-status-function))
  (when (and (boundp 'my-battery-timer) (timerp  my-battery-timer))
    (cancel-timer my-battery-timer))
  (setq my-battery-timer
        ;; Check periodically if went off-line and
        ;; discharging battery needs to be displayed
        (run-at-time t 600 (lambda ()
                             (display-battery-mode
                              (if (member (cdr (assoc ?L (funcall battery-status-function)))
                                          '("AC" "on-line"))
                                  0 1))))))
#+end_src

** Fix inconsistency in motion keys

There was no symmetry for sexp like in =right-char= / =left-char=
and =right-word= / =left-word= ([[bug:36923]])

#+begin_src emacs-lisp
(defun right-sexp (&optional arg)
  "Move across one balanced expression (sexp) to the right.
Depending on the bidirectional context, this may move either forward
or backward in the buffer.  See more at `forward-sexp'."
  (interactive "^p")
  (if (eq (current-bidi-paragraph-direction) 'left-to-right)
      (forward-sexp arg)
    (backward-sexp arg)))

(defun left-sexp (&optional arg)
  "Move across one balanced expression (sexp) to the left.
Depending on the bidirectional context, this may move either backward
or forward in the buffer.  See more at `backward-sexp'."
  (interactive "^p")
  (if (eq (current-bidi-paragraph-direction) 'left-to-right)
      (backward-sexp arg)
    (forward-sexp arg)))

(define-key global-map [(control left)]       'left-sexp)
(define-key global-map [(control right)]      'right-sexp)
(define-key global-map [(control kp-left)]    'left-sexp)
(define-key global-map [(control kp-right)]   'right-sexp)
(define-key global-map [(control meta left)]  'left-word)
(define-key global-map [(control meta right)] 'right-word)
(define-key global-map [(control meta up)]    'backward-paragraph)
(define-key global-map [(control meta down)]  'forward-paragraph)
#+end_src

Fix controversial keybindings added in Emacs 23:

#+begin_src emacs-lisp
(define-key global-map [home] 'beginning-of-visual-line)
(define-key global-map [end]  'end-of-visual-line)
(define-key global-map [up]   'previous-line)
(define-key global-map [down] 'next-line)
#+end_src

Fix ~compare-windows~:

#+begin_src emacs-lisp
(define-key global-map [(control ?=)] 'compare-windows)
;; alternative: (lambda () (interactive) (compare-windows t))

;; I often mistype `compare-windows' as `comapre-windows', allow both:
(defalias 'comapre-windows 'compare-windows)
#+end_src

* Other

** No blinking

Blinking cursors are distracting - turn blink OFF:
here ~(*) (*) (*)~ indicates how cursor blinks.

#+begin_src emacs-lisp
(and (fboundp 'blink-cursor-mode) (blink-cursor-mode (- (*) (*) (*))))
#+end_src

* Local Variables :noexport:

~time-stamp~ in these local variables specifies the format
of the property =DATE= at the beginning of this file, so that
on saving it is updated automatically.

- Local Variables:
- eval: (add-hook 'before-save-hook 'time-stamp nil t)
- time-stamp-start: "DATE: "
- time-stamp-format: "%:y-%02m-%02d"
- time-stamp-end: "$"
- time-stamp-line-limit: 15
- End:
